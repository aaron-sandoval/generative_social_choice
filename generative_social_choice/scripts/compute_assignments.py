from pathlib import Path

import pandas as pd

from generative_social_choice.utils.helper_functions import get_base_dir_path
from generative_social_choice.slates.voting_algorithms import (
    VotingAlgorithm,
    SequentialPhragmenMinimax,
    GreedyTotalUtilityMaximization,
    RatedVoteCase,
)


UTILITY_MATRIX_FILE = get_base_dir_path() / "data/demo_data/TEST_utility_matrix.csv"
STATEMENT_ID_FILE = get_base_dir_path() / "data/demo_data/TEST_utility_matrix_statements.csv"


def compute_assignments(
        voting_algorithm: VotingAlgorithm,
        utility_matrix_file: Path,
        statement_id_file: Path,
        slate_size: int,
    ) -> tuple[list[str], pd.DataFrame, dict[str, str]]:
    """
    Select a slate of candidates and assign them to the voters.

    # Arguments
    - `voting_algorithm: VotingAlgorithm`: The algorithm to use for assigning voters
    - `utility_matrix_file: Path`: CSV with all utilities, as generated by create_utility_matrix(). Statement IDs
        are used as column names from the second column onwards, the agent IDs are in the first column.
    - `statement_id_file: Path`: CSV file with statement strings for all statement IDs used in the utility matrix
    - `slate_size: int`: The number of candidates to be selected

    # Returns
    - `slate: list[str]`: The slate of candidates to be selected as IDs
    - `assignments: pd.DataFrame`: The assignments of the candidates to the voters with the following columns:
        - `candidate_id`: The candidate to which the voter is assigned
        - Various other columns may be present depending on the algorithm
    - `statement_id_mapping: dict[str, str]`: Dictionary mapping candidate IDs to the corresponding statement strings
        for all candidates occurring in `slate`.
    """
    utilities_df = pd.read_csv(utility_matrix_file, index_col=0)
    statement_df = pd.read_csv(statement_id_file, index_col=0)

    # Utility function to get statements based on IDs (column names in utility df)
    id_to_statement = lambda statement: statement_df.loc[statement]["statement"]

    rated_vote_case = RatedVoteCase(rated_votes=utilities_df, slate_size=slate_size)

    slate, assignments = voting_algorithm.vote(
        rated_vote_case.rated_votes.copy(),  # Voting algorithms might append columns
        rated_vote_case.slate_size,
    )

    return slate, assignments, {statement_id: id_to_statement(statement_id) for statement_id in slate}

if __name__=="__main__":
    slate, assignments, id_mapping = compute_assignments(
        voting_algorithm=SequentialPhragmenMinimax(),
        #voting_algorithm=GreedyTotalUtilityMaximization(),
        utility_matrix_file=UTILITY_MATRIX_FILE,
        statement_id_file=STATEMENT_ID_FILE,
        slate_size=2,
    )

    print("RESULT\n")

    print("Slate found by algorithm:", slate)
    for statement_id in slate:
        print(f"{statement_id}: {id_mapping[statement_id].replace("\n", " ")}")

    print("\nAssignments:")
    for statement_id in slate:
        num_assigned = len(assignments[assignments["candidate_id"]==statement_id])
        print(f"{statement_id}: {num_assigned}")
    
    #TODO Display some things about resulting utilities (get these from utilities_df)